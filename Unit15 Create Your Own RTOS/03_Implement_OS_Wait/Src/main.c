/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "core_cm3.h"

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "Scheduler.h"
#include "MY_RTOS.h"
#include "CortexMX_OS_Porting.h"

Task_ref Task1, Task2, Task3, Task4 ;
unsigned char Task1LED,Task2LED,Task3LED, Task4LED ;
void task1(void)
{
    static int count = 0 ;

    while(1)
    {
        /*Task1 Code*/
        Task1LED ^= 1 ;
        count++;
        if(count == 30)
        {
            MYRTOS_ActivateTask(&Task4);
            count = 0 ;
        }
        // 100ms
        MYRTOS_TaskWait(100,&Task1);
    }
}
void task2(void)
{
    while(1)
    {
        /*Task2 Code*/
        Task2LED ^= 1 ;
        // 300ms
        MYRTOS_TaskWait(300,&Task2);

    }
}

void task3(void)
{
    while(1)
    {
        /*Task3 Code*/
        Task3LED ^= 1 ;
        // 500ms
        MYRTOS_TaskWait(500,&Task3);

    }
}

void task4(void)
{
    static int count = 0 ;
    while(1)
    {
        /*Task4 Code*/
        Task4LED ^= 1 ;
        count++ ;
        MYRTOS_TaskWait(1000,&Task4);

    }
}



int main(void)
{
    MYRTOS_error_ID error = NoError;
    //HW_Init (Initialize ClockTree, ResetController)
    HW_Init();
    if(MYRTOS_Init() != NoError)
        while(1);

    Task1.Stack_Size = 1024; //1kb
    Task1.p_TaskEntry = task1 ;
    Task1.Priority = 3 ;
    strcpy(Task1.TaskName,"task_1") ;

    Task2.Stack_Size = 1024; //1kb
    Task2.p_TaskEntry = task2 ;
    Task2.Priority = 3 ;
    strcpy(Task2.TaskName,"task_2") ;

    Task3.Stack_Size = 1024; //1kb
    Task3.p_TaskEntry = task3 ;
    Task3.Priority = 3 ;
    strcpy(Task3.TaskName,"task_3") ;

    Task4.Stack_Size = 1024; //1kb
    Task4.p_TaskEntry = task4 ;
    Task4.Priority = 1 ;
    strcpy(Task4.TaskName,"task_4") ;

    error += MYRTOS_Create_Task(&Task1);
    error += MYRTOS_Create_Task(&Task2);
    error += MYRTOS_Create_Task(&Task3);
    error += MYRTOS_Create_Task(&Task4);

    MYRTOS_ActivateTask(&Task1);
    MYRTOS_ActivateTask(&Task2);
    MYRTOS_ActivateTask(&Task3);

    MYRTOS_STARTOS();

    /* Loop forever */
    while(1)
    {

    }
}
