/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//************************************************************************************************
//	Terminal <----> USART1 : MCU1 : (SPI1 Master) --> (SPI2 Slave) : MCU2 : USART2 ---> terminal 2
// ***********************************************************************************************


#define MCU_Act_As_Master
//#define MCU_Act_As_Slave


#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "STM32F103x6.h"
#include "STM32_F103C6_GPIO_Driver.h"
#include "STM32_F103C6_EXTI_Driver.h"
#include "STM32_F103C6_USART_Driver.h"
#include "STM32_F103C6_SPI_Driver.h"


void clock_init()
{
	//Enable clock for GPIO
	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();
	//Enable clock for AFIO
	RCC_AFIO_CLK_EN();
}

uint8_t ch ;


void SPI1_IRQ_Callback(struct S_IRQ_SRC irq_src)
{

#ifdef MCU_Act_As_Slave

	if(irq_src.RXNE)
	{
		ch = 0xF ;	//test transmit to Master
		MCAL_SPI_TX_RX(SPI1, (uint16_t*)&ch , pollingDisable) ;
		MCAL_UART_SendData(USART1, (uint16_t*)&ch , enable) ;
	}

#endif

}

void UART_IRQ_Callback(void)
{

#ifdef MCU_Act_As_Master

	MCAL_UART_ReceiveData(USART1, (uint16_t*)&ch, disable);
	MCAL_UART_SendData(USART1, (uint16_t*)&ch, enable);

	//Send to SPI

	//Force the slave select (low) to send data
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
	MCAL_SPI_TX_RX(SPI1, (uint16_t*)&ch, pollingEnable);

	//Force the slave select (high) idle Mode
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);

#endif

}

int main(void)
{

	GPIO_PinConfig_t PinCfg;

	UART_Config uartCFG ;

	clock_init();

	//=================UART INIT=================
	//PA9 	TX
	//PA10 	RX
	//PA11	CTS
	//PA12	RTS

	uartCFG.BaudRate = UART_BaudRate_115200 ;
	uartCFG.HwFlowCtl = UART_HwFlowCtl_NONE ;

	uartCFG.IRQ_Enable = UART_IRQ_Enable_RXNEIE ;

	uartCFG.P_IRQ_Callback = UART_IRQ_Callback ;

	uartCFG.Parity = UART_Parity_NONE ;
	uartCFG.Payload_Length = UART_Payload_Length_8B ;
	uartCFG.StopBits = UART_StopBits_1 ;
	uartCFG.USART_Mode = UART_Mode_TX_RX ;

	MCAL_UART_Init(USART1, &uartCFG) ;
	MCAL_UART_GPIO_Set_pins(USART1);

	//=================SPI INIT=================
	//PA4	SPI1_NSS
	//PA5	SPI1_SCK
	//PA6	SPI1_MISO
	//PA7	SPI1_MOSI
	SPI_Config SPI1CFG ;

	//Common configuration between master and slave
	SPI1CFG.CLKPhase = SPI_CLKPhase_2EDGE_first_data_capture_edge ;
	SPI1CFG.CLKPolarity = SPI_CLKPolarity_HIGH_when_idle ;
	SPI1CFG.DataSize = SPI_DataSize_8BIT ;
	SPI1CFG.Frame_Format = SPI_Frame_Format_MSB_Transmit_First ;
	//Assume by default pclk2 = 8 MHz
	SPI1CFG.BAUDRATEPRESCALER = SPI_BAUDRATEPRESCALER_8 ;
	SPI1CFG.Communication_Mode = SPI_DIRECTION_2LINES ;

#ifdef MCU_Act_As_Master

	SPI1CFG.Device_Mode = SPI_Device_Mode_Master ;
	SPI1CFG.IRQ_Enable = SPI_IRQ_Enable_NONE ;
	SPI1CFG.NSS = SPI_NSS_Soft_NSSInternalSoft_Set ;
	SPI1CFG.P_IRQ_Callback = NULL ;

	//configure SS on PORTA Pin 4 by GPIO
	PinCfg.GPIO_PinNumber = GPIO_PIN_4 ;
	PinCfg.GPIO_MODE = GPIO_MODE_OUTPUT_PP ;
	PinCfg.GPIO_Output_Speed = GPIO_SPEED_10M ;
	MCAL_GPIO_Init(GPIOA, &PinCfg) ;

	//Force the slave select (high) idle Mode
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);

#endif

#ifdef MCU_Act_As_Slave

	SPI1CFG.Device_Mode = SPI_Device_Mode_Slave ;
	SPI1CFG.IRQ_Enable = SPI_IRQ_Enable_RXNEIE ;
	SPI1CFG.NSS = SPI_NSS_Hard_Slave ;
	SPI1CFG.P_IRQ_Callback = SPI1_IRQ_Callback ;


#endif


	MCAL_SPI_Init(SPI1, &SPI1CFG) ;
	MCAL_SPI_GPIO_Set_pins(SPI1) ;




	/* Loop forever */
	while(1)
	{

	}
}

